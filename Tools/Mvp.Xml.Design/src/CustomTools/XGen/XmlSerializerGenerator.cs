using System;
using System.Collections;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.IO;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Xml.Serialization;
using System.Text;

namespace Mvp.Xml.Design.CustomTools.XGen
{
	internal class XmlSerializerGenerator
	{
		#region Constants

		/// <summary>
		/// In the <see cref="PrivateReadMethods"/> regular expression, 
		/// the return type of the read method.
		/// </summary>
		const string ReadMethodReturnType = "return";

		/// <summary>
		/// In the <see cref="PrivateReadMethods"/> regular expression, 
		/// full method signature excluding return type.
		/// </summary>
		const string ReadMethodFullSignature = "method";

		/// <summary>
		/// In the <see cref="PrivateReadMethods"/> regular expression, 
		/// matched method name.
		/// </summary>
		const string ReadMethodName = "name";

		/// <summary>
		/// In the <see cref="PrivateReadMethods"/> regular expression, 
		/// matched method arguments.
		/// </summary>
		const string ReadMethodArguments = "arguments";

		/// <summary>
		/// In the <see cref="PublicRead"/> or <see cref="PublicWrite"/> regular expressions, 
		/// matched name of the object being read or written.
		/// </summary>
		const string MethodObjectName = "object";

		/// <summary>
		/// In the <see cref="PublicRead"/> or <see cref="PublicWrite"/> regular expressions, 
		/// the name of the matched public read or write method.
		/// </summary>
		const string MethodName = "method";

		/// <summary>
		/// In the <see cref="ClassDeclaration"/> regular expression, 
		/// the matched name of the class being declared.
		/// </summary>
		const string ClassDeclarationName = "className";

		/// <summary>
		/// In the <see cref="ClassDeclaration"/> regular expression, 
		/// the matched name of the base class of the class being declared.
		/// </summary>
		const string ClassDeclarationBaseType = "baseClass";

		#endregion

		#region Regular Expressions

		/// <summary>
		/// Matches all non-void methods called Read_[identifier]([...arguments...])
		/// </summary>
		static Regex PrivateReadMethods = new Regex(@"
			# Returned type #
			(?<return>[^\s]+)\s
			# Method call start #
				(?<method>
				(?<name>Read\d+_
				# Object being read #
				(?<object>[^\(]+))\(
				# Method arguments #
				(?<arguments>[^\)]+)
			# Method call end #
				\))\s{",
			RegexOptions.IgnorePatternWhitespace | RegexOptions.Compiled |
			RegexOptions.Multiline);

		/// <summary>
		/// Matches a public object Read_[object] method.
		/// </summary>
		static Regex PublicRead = new Regex(@"public object (?<method>Read\d+_(?<object>[^\(]+))",
			RegexOptions.Compiled | RegexOptions.Multiline);

		/// <summary>
		/// Matches a public void Write_[object] method.
		/// </summary>
		static Regex PublicWrite = new Regex(@"public void (?<method>Write\d+_(?<object>[^\(]+))",
			RegexOptions.Compiled | RegexOptions.Multiline);

		/// <summary>
		/// Matches an assembly level AssemblyVersionAttribute attribute declaration.
		/// </summary>
		static Regex AssemblyVersion = new Regex(@"\[assembly:System.Reflection.AssemblyVersionAttribute[^\]]*\]",
			RegexOptions.Compiled | RegexOptions.Multiline);

		/// <summary>
		/// Matches an identifier previous to a space or coma.
		/// </summary>
		static Regex RemoveTypeFromArguments = new Regex(@"[^\s,]+[\s]", RegexOptions.Compiled);

		/// <summary>
		/// Matches the full class declaration, capturing the class name and base type.
		/// </summary>
		static Regex ClassDeclaration = new Regex(@"public( abstract)?( sealed)? class (?<className>[^\s]+) :\s?(?<baseClass>[^\s]+)",
			RegexOptions.Compiled | RegexOptions.Multiline | RegexOptions.ExplicitCapture);

		/// <summary>
		/// Matches only the "public [modifiers] class" part. Used for replacing the visibility.
		/// </summary>
		static Regex SimpleClassDeclaration = new Regex(@"public(?<modifiers>( abstract)?( sealed)?( partial)?) class",
			RegexOptions.Compiled | RegexOptions.Multiline | RegexOptions.ExplicitCapture);

		#endregion

		#region Code templates

		/// <summary>
		/// Template for the override for each element being read.
		/// {0}=Return type
		/// {1}=Method name
		/// {2}=Delegate name
		/// {3}=Event name
		/// {4}=Arguments with type definition
		/// {5}=Arguments with no type
		/// </summary>
		const string TemplateMethodOverride = @"
		/// <remarks/>
		protected override {0} {1}({4})
		{{
			{0} obj = base.{1}({5});
			{2} handler = {3};
			if (handler != null)
				handler(obj);

			return obj;
		}}";

		/// <summary>
		/// Template for the public Read method for the root object 
		/// in the custom reader firing events.
		/// {0}=Return type
		/// {1}=Read method name generated by serializer for root object.
		/// </summary>
		const string TemplateReadMethod = @"
		/// <summary>Reads an object of type {0}.</summary>
		internal {0} Read()
		{{
			return ({0}) {1}();
		}}";

		/// <summary>
		/// Template for the public Write method for the root object 
		/// in the custom writer.
		/// {0}=Object type name
		/// {1}=Write method name generated by serializer for root object.
		/// </summary>
		const string TemplateWriteMethod = @"
		/// <summary>Writes an object of type {0}.</summary>
		internal void Write({0} value)
		{{
			{1}(value);
		}}";

		/// <summary>
		/// Template for custom serializer class members.
		/// {0}=Name of the serializer class
		/// {1}=Reader type name
		/// {2}=Writer type name
		/// {3}=Root object type
		/// </summary>
		const string TemplateCustomSerializer = @"
		{1} _reader;
		{2} _writer;

		/// <summary>Constructs the serializer.</summary>
		public {0}()
		{{
		}}

		/// <summary>Constructs the serializer with a pre-built reader.</summary>
		public {0}({1} reader)
		{{
			_reader = reader;
		}}

		/// <summary>Constructs the serializer with a pre-built writer.</summary>
		public {0}({2} writer)
		{{
			_writer = writer;
		}}

		/// <summary>Constructs the serializer with pre-built reader and writer.</summary>
		public {0}({1} reader, {2} writer)
		{{
			_reader = reader;
			_writer = writer;
		}}

		/// <remarks/>
		protected override System.Xml.Serialization.XmlSerializationReader CreateReader()
		{{
			if (_reader != null) return _reader;
			
			return base.CreateReader();
		}}

		/// <remarks/>
		protected override System.Xml.Serialization.XmlSerializationWriter CreateWriter()
		{{
			if (_writer != null) return _writer;
			
			return base.CreateWriter();
		}}";

		#endregion Code templates

		#region Private helper methods

		public static string GenerateCode(Type[] types, string targetNamespace)
		{
			string output = String.Empty;

			foreach (Type type in types)
			{
				output += GenerateCodeForType(type, targetNamespace, output);
			}

			return output;
		}

		private static string GenerateCodeForType(Type type, string targetNamespace, string previousOutput)
		{
			string output = GetXmlSerializerOutput(type);

			System.CodeDom.CodeNamespace ns = InitializeCodeDom(targetNamespace);

			output = CleanupXmlSerializerCode(targetNamespace, output);

			// Find the methods that are the entry points for reading and writing the object.
			Match readMatch = PublicRead.Match(output);
			Match writeMatch = PublicWrite.Match(output);

			string rootObject = readMatch.Groups[MethodObjectName].Value;

			output = MakeSerializerPartial(output, rootObject);
			output = RenameClasses(output, rootObject);
			output = NestTypesOnSerialier(output, rootObject);

			output = AppendReaderWriterMembersToObjectSerializer(type, output, rootObject);

			CodeTypeDeclaration readerDeclaration = CreateAndAddEventRisingReader(targetNamespace, ns, rootObject, output, previousOutput);
			output = PrivateReadMethodsToProtectedVirtual(output);
			CodeTypeDeclaration writerDeclaration = CreateAndAddTypedWriter(targetNamespace, ns, rootObject);

			// Renders TemplateReadMethod (see that constant declaration)
			output = AddTypedRead(readerDeclaration, type, output, readMatch);
			// Renders TemplateWriteMethod (see that constant declaration)
			output = AddTypedWrite(writerDeclaration, type, output, writeMatch);

			output = MergeOutputWithCodeDom(output, ns);
			output = MakeClassesInternal(output);
			output = NormalizeLineEndings(output);
			output = NestTypesOnSerialier(output, rootObject);
			output = FixInstantiationOfNestedTypes(output, rootObject);

			output = @"
#pragma warning disable 0642, 0219
" + output + @"
#pragma warning restore 0642, 0219";
			output = CustomTool.GetToolGeneratedCodeWarning(typeof(XGenTool)) + output;


#if DEBUG
			return @"#region Original XmlSerializer code
/* -------------------------------------------------------------------------------------
" + GetXmlSerializerOutput(type) + @"
-------------------------------------------------------------------------------------*/
" + @"#endregion
" + output;
#else
			return output;
#endif
		}

		private static string MakeSerializerPartial(string output, string rootObject)
		{
			string rootSerializer = rootObject + "Serializer";
			return output.Replace("public sealed class " + rootSerializer, "public sealed partial class " + rootSerializer);
		}

		private static string FixInstantiationOfNestedTypes(string output, string rootObject)
		{
			output = output.Replace("new BaseWriter", "new " + rootObject + "Serializer.BaseWriter");
			output = output.Replace("new BaseReader", "new " + rootObject + "Serializer.BaseReader");

			return output;
		}

		private static string NormalizeLineEndings(string output)
		{
			// Sometimes VS doesn't like the line endings we got from the XmlSerializer code...
			StringWriter endlines = new StringWriter();
			using (StringReader sr = new StringReader(output))
			{
				string line;
				while ((line = sr.ReadLine()) != null)
				{
					endlines.WriteLine(line);
				}
			}

			output = endlines.ToString();
			return output;
		}

		private static string MakeClassesInternal(string output)
		{
			// Make all classes internal instead of public.
			return SimpleClassDeclaration.Replace(output, "internal${modifiers} class");
		}

		private static string MergeOutputWithCodeDom(string output, System.CodeDom.CodeNamespace ns)
		{
			CodeGeneratorOptions opt = new CodeGeneratorOptions();
			opt.BracingStyle = "C";
			StringWriter finalcode = new StringWriter();
			new Microsoft.CSharp.CSharpCodeProvider().GenerateCodeFromNamespace(ns, finalcode, opt);
			finalcode.WriteLine(output);

			return finalcode.ToString();
		}

		private static string NestTypesOnSerialier(string output, string rootObject)
		{
			string rootSerializer = rootObject + "Serializer";
			// Nest public reader/writer classes first
			MatchCollection classMatches = ClassDeclaration.Matches(output);
			for (int i = classMatches.Count - 1; i >= 0; i--)
			{
				Match m = classMatches[i];
				// Skip the serializer itself
				if (m.Groups[ClassDeclarationName].Value.StartsWith(rootObject))
				{
					continue;
				}

				int closePosition = FindClosingBracketPosition(output, output.IndexOf('{', m.Index));
				output = output.Insert(++closePosition, "\n\t}");
				output = output.Insert(m.Index, "public partial class " +
					rootSerializer + " {\n\t");
			}

			return output;
		}

		private static int FindClosingBracketPosition(string output, int openPosition)
		{
			int openCount = 0;

			for (int i = openPosition; i < output.Length; i++)
			{
				if (output[i] == '{') openCount++;
				if (output[i] == '}') openCount--;

				if (openCount == 0) return i;
			}

			throw new ArgumentException(Properties.Resources.XGenTool_UnclosedBrackets);
		}

		private static string PrivateReadMethodsToProtectedVirtual(string output)
		{
			// Turn all private methods into protected virtual, as they are overriden 
			// by the custom event rising reader.
			output = PrivateReadMethods.Replace(output, @"/// <remarks/>
        protected virtual ${return} ${method} {");
			return output;
		}

		private static CodeTypeDeclaration CreateAndAddTypedWriter(string targetNamespace, CodeNamespace ns, string rootObject)
		{
			CodeTypeDeclaration writerDeclaration = new CodeTypeDeclaration(rootObject + "Writer");
			writerDeclaration.BaseTypes.Add(rootObject + "Serializer.BaseWriter");
			writerDeclaration.Comments.Add(new CodeCommentStatement(
				"/// <summary>Custom writer for " + rootObject + " instances.</summary>", true));
			ns.Types.Add(writerDeclaration);
			return writerDeclaration;
		}

		private static CodeTypeDeclaration CreateAndAddEventRisingReader(string targetNamespace, CodeNamespace ns,
			string rootObject, string output, string previousOutput)
		{
			CodeTypeDeclaration readerDeclaration = new CodeTypeDeclaration(rootObject + "Reader");
			readerDeclaration.BaseTypes.Add(rootObject + "Serializer.BaseReader");
			readerDeclaration.Comments.Add(new CodeCommentStatement(
				"/// <summary>Custom reader for " + rootObject + " instances.</summary>", true));
			ns.Types.Add(readerDeclaration);

			// For each read method
			Match readMethodMatch = PrivateReadMethods.Match(output);
			while (readMethodMatch.Success)
			{
				string objectBeingRead = readMethodMatch.Groups[MethodObjectName].Value;
				// Skip the generic reading method.
				if (objectBeingRead.ToLower() == "object")
				{
					readMethodMatch = readMethodMatch.NextMatch();
					continue;
				}

				string delegateName = objectBeingRead + "DeserializedHandler";
				if (!previousOutput.Contains(delegateName))
				{
					// Create a delegate for the event to expose. 
					// public delegate void [objectBeingRead]DeserializedHandler(Mvp.Xml.Design.Tests.Customer customer);
					CodeTypeDelegate del = new CodeTypeDelegate(delegateName);
					del.Parameters.Add(new CodeParameterDeclarationExpression(
						readMethodMatch.Groups[ReadMethodReturnType].Value,
						MakeFirstLower(objectBeingRead)));
					del.Comments.Add(new CodeCommentStatement("/// <remarks/>", true));
					ns.Types.Add(del);
				}

				// Expose event.
				// public event [objectBeingRead]DeserializedHandler [objectBeingRead]Deserialized;
				CodeMemberEvent ev = new CodeMemberEvent();
				ev.Name = objectBeingRead + "Deserialized";
				ev.Attributes = MemberAttributes.Public;
				ev.Type = new CodeTypeReference(delegateName);
				ev.Comments.Add(new CodeCommentStatement("/// <remarks/>", true));
				readerDeclaration.Members.Add(ev);

				// Override base method.
				string methodOverride = String.Format(
					TemplateMethodOverride,
					readMethodMatch.Groups[ReadMethodReturnType].Value,
					readMethodMatch.Groups[ReadMethodName].Value,
					delegateName,
					ev.Name,
					readMethodMatch.Groups[ReadMethodArguments].Value,
					// Arguments contain type + parameter name. Remove type for method call.
					RemoveTypeFromArguments.Replace(
						readMethodMatch.Groups[ReadMethodArguments].Value, ""));
				readerDeclaration.Members.Add(new CodeSnippetTypeMember(methodOverride));

				readMethodMatch = readMethodMatch.NextMatch();
			}
			return readerDeclaration;
		}

		private static string AddTypedRead(CodeTypeDeclaration reader, Type type, string output, Match readMatch)
		{
			// Add the "final" public read method.
			reader.Members.Add(new CodeSnippetTypeMember(
				String.Format(TemplateReadMethod,
				type.FullName, readMatch.Groups[MethodName].Value)));
			// Turn original public method into internal protected
			output = PublicRead.Replace(output, "protected internal object ${method}");

			return output;
		}

		private static string AddTypedWrite(CodeTypeDeclaration writer, Type type, string output, Match writeMatch)
		{
			// Add the "final" public write method.
			writer.Members.Add(new CodeSnippetTypeMember(
				String.Format(TemplateWriteMethod,
				type.FullName, writeMatch.Groups[MethodName].Value)));
			// Turn original public method into internal protected
			output = PublicWrite.Replace(output, "protected internal void ${method}");

			return output;
		}

		private static string MakeFirstLower(string value)
		{
			char[] name = value.ToCharArray();
			name[0] = Char.ToLower(name[0]);
			return new string(name);
		}

		private static string AppendReaderWriterMembersToObjectSerializer(Type type, string output, string rootObject)
		{
			string readerWriterMembers = String.Format(
				TemplateCustomSerializer,
				rootObject + "Serializer",
				rootObject + "Reader",
				rootObject + "Writer",
				type.FullName);
			output = output.Replace(": " + rootObject + "SerializerBase {",
				": " + rootObject + "SerializerBase {\n" + readerWriterMembers);
			return output;
		}

		private static string RenameClasses(string output, string rootObject)
		{
			// Give generated classes more friendly names.
			output = output.Replace("XmlSerializationWriter" + rootObject, "BaseWriter");
			output = output.Replace("XmlSerializationReader" + rootObject, "BaseReader");
			output = output.Replace("XmlSerializer1", rootObject + "SerializerBase");

			return output;
		}

		private static string CleanupXmlSerializerCode(string targetNamespace, string output)
		{
			// Remove assembly version attribute.
			output = AssemblyVersion.Replace(output, "");
			// Replace namespace.
			output = output.Replace("Microsoft.Xml.Serialization.GeneratedAssembly", targetNamespace);
			return output;
		}

		private static System.CodeDom.CodeNamespace InitializeCodeDom(string targetNamespace)
		{
			System.CodeDom.CodeNamespace ns = new System.CodeDom.CodeNamespace(targetNamespace);
			ns.Imports.Add(new CodeNamespaceImport("System.Xml.Serialization"));
			ns.Imports.Add(new CodeNamespaceImport("System"));
			//			CodeTypeDeclaration serializer = new CodeTypeDeclaration(type.Name + "Serializer");
			//			serializer.BaseTypes.Add(typeof(XmlSerializer));
			//			serializer.Comments.Add(new CodeCommentStatement(
			//				"<summary>Custom serializer for " + type.Name + " type.</summary", true));
			//			ns.Types.Add(serializer);
			return ns;
		}

		private static string GetXmlSerializerOutput(Type type)
		{
			string output;
			XmlSerializer ser = new XmlSerializer(type);

			// Here starts the horrible reflection hacks!

			//ser.tempAssembly.assembly.Location
			FieldInfo fitempasm = ser.GetType().GetField("tempAssembly", BindingFlags.NonPublic | BindingFlags.Instance);
			object tempasm = fitempasm.GetValue(ser);
			FieldInfo fiasm = tempasm.GetType().GetField("assembly", BindingFlags.NonPublic | BindingFlags.Instance);
			Assembly asm = (Assembly)fiasm.GetValue(tempasm);

			string codebase = new Uri(asm.CodeBase).LocalPath;
			string code = Path.Combine(
				Path.GetDirectoryName(codebase),
				Path.GetFileNameWithoutExtension(codebase) + ".0.cs");

			string original;

			using (StreamReader sr = new StreamReader(code))
			{
				output = sr.ReadToEnd();
				original = output;
			}
			return output;
		}

		#endregion
	}
}
